<!DOCTYPE html>
<html>
<body>

  <canvas id="myCanvas" ></canvas>
  <button onclick="start()">Start</button>
  <button onclick="myFunction()">BFS</button>

</body>
<script>



function Point(x, y) {
  this.x = x;
  this.y = y;
}
const NUM_OF_VERTEXES = 7;
const GAP_BETWEEN_VERTEXES = 80;
const VERTEXES_SIZE = 40;
var vertexArray = [];
var edgeArray = new Array(NUM_OF_VERTEXES);

function start() {
  var canvas = document.getElementById("myCanvas");
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight - 40;

  var ctx = canvas.getContext("2d");
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  vertexArray = [];

  var i;
  for (i = 0; i < NUM_OF_VERTEXES; i++) {
    var candidatePoint;
    do {
      candidatePoint = new Point(
        Math.max(VERTEXES_SIZE,(Math.random() * canvas.width) - VERTEXES_SIZE)
        ,Math.max(VERTEXES_SIZE,(Math.random() * canvas.height) -VERTEXES_SIZE));

      }
      while (!isPointNotInRadiusOfOtherPoints(vertexArray,candidatePoint));
      vertexArray.push(candidatePoint)
      edgeArray[i] = [(i +1) % 7];
    }

    //drawArrows
    for (i = 0; i < edgeArray.length; i++) {
      var edge = edgeArray[i][0];
      var edgePoint1 = vertexArray[i];
      var edgePoint2 = vertexArray[edge];

      var lineAngle = ((edgePoint2.y - edgePoint1.y)/(edgePoint2.x - edgePoint1.x));
      var newX = (edgePoint2.x - VERTEXES_SIZE)
      if (edgePoint1.x > edgePoint2.x) {
        var newX = (edgePoint2.x + VERTEXES_SIZE)
      }
      var newY = lineAngle *(newX - edgePoint1.x) + edgePoint1.y


      var circle = {
          radius : VERTEXES_SIZE,
          center : edgePoint2,
      }
      var line = {
    p1 : edgePoint1,
    p2 : edgePoint2,
    }
console.log(inteceptCircleLineSeg(circle,line));
      //circle
      //(x-edgePoint2.x)^2 + (y-edgePoint2.y)^2 = VERTEXES_SIZE^2
      //line
      // y = (x-edgePoint2.x)*lineAngle + edgePoint2.y



      // drawArrow(edgePoint1.x,edgePoint1.y,newX,newY,'black',1);
      p = inteceptCircleLineSeg(circle,line)[0]
      drawArrow(edgePoint1.x,edgePoint1.y,p.x,p.y,'black',1);
    }


    drawAllVertexes(vertexArray);


  }

  function isPointNotInRadiusOfOtherPoints(arrayOfPoints,point) {
    var i;
    for (i = 0; i < arrayOfPoints.length; i++) {

      var iterationPoint = arrayOfPoints[i];

      if (Math.abs(iterationPoint.x - point.x) < GAP_BETWEEN_VERTEXES ||
      Math.abs(iterationPoint.y - point.Y) < GAP_BETWEEN_VERTEXES){
        return false;
      }
    }
    return true;
  }
  function drawAllVertexes(arrayOfPoints) {
    var i;
    for (i = 0; i < arrayOfPoints.length; i++) {
      drawVertex(arrayOfPoints[i].x,arrayOfPoints[i].y,i);
    }
  }

  function drawVertex(x,y,text) {
    var c = document.getElementById("myCanvas");
    var ctx = c.getContext("2d");
    ctx.beginPath();
    ctx.fillStyle = 'orange';
    ctx.arc(x,y,VERTEXES_SIZE,0,2*Math.PI);
    ctx.fill();

    ctx.fillStyle = 'black';
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.font = '16px serif';
    ctx.fillText(text, x,y);


  }

  function drawArrow(startX, startY, endX, endY,color,lineSize){
    var c = document.getElementById("myCanvas");
    var ctx = c.getContext("2d");

    var headLength = 10;   // length of head in pixels
    var angle = Math.atan2(endY - startY,endX - startX);
    ctx.moveTo(startX, startY);
    ctx.lineTo(endX, endY);
    ctx.lineTo(endX - (headLength * Math.cos(angle - Math.PI/6)) ,
    endY - (headLength * Math.sin(angle - Math.PI/6)));
    ctx.moveTo(endX, endY);
    ctx.lineTo(endX - (headLength * Math.cos(angle + Math.PI/6)),
    endY - (headLength * Math.sin(angle + Math.PI/6)));
    ctx.strokeStyle = color;
    ctx.lineWidth = lineSize;
    ctx.stroke();

  }

  function inteceptCircleLineSeg(circle, line){
      var a, b, c, d, u1, u2, ret, retP1, retP2, v1, v2;
      v1 = {};
      v2 = {};
      v1.x = line.p2.x - line.p1.x;
      v1.y = line.p2.y - line.p1.y;
      v2.x = line.p1.x - circle.center.x;
      v2.y = line.p1.y - circle.center.y;
      b = (v1.x * v2.x + v1.y * v2.y);
      c = 2 * (v1.x * v1.x + v1.y * v1.y);
      b *= -2;
      d = Math.sqrt(b * b - 2 * c * (v2.x * v2.x + v2.y * v2.y - circle.radius * circle.radius));
      if(isNaN(d)){ // no intercept
          return [];
      }
      u1 = (b - d) / c;  // these represent the unit distance of point one and two on the line
      u2 = (b + d) / c;
      retP1 = {};   // return points
      retP2 = {}
      ret = []; // return array
      if(u1 <= 1 && u1 >= 0){  // add point if on the line segment
          retP1.x = line.p1.x + v1.x * u1;
          retP1.y = line.p1.y + v1.y * u1;
          ret[0] = retP1;
      }
      if(u2 <= 1 && u2 >= 0){  // second add point if on the line segment
          retP2.x = line.p1.x + v1.x * u2;
          retP2.y = line.p1.y + v1.y * u2;
          ret[ret.length] = retP2;
      }
      return ret;
  }

  start();

</script>

</html>



//add arrows. after adding - make sure that they are not crossing each other.


//BFS (button)
//split into js files
